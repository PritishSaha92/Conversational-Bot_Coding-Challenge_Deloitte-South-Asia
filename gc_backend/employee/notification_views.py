from django.utils import timezone
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from datasets.models import TablesEmployee
from .models import ChatMessage
from accounts.models import CustomUser
from datetime import datetime, time
import json
import logging
from django.core.mail import send_mail
from django.conf import settings

def send_admin_alert(employee):
    """Send alert emails to all admin users when an employee is marked as alerted."""
    try:
        # Fetch all admin users
        admin_users = CustomUser.objects.filter(role='admin')
        
        if not admin_users.exists():
            logger = logging.getLogger(__name__)
            logger.warning(f"No admin users found to send alert for employee {employee.employee_id}")
            return
        
        # Get employee details
        try:
            user = CustomUser.objects.get(username=employee.employee_id)
            employee_name = f"{user.first_name} {user.last_name}".strip() or user.username
        except CustomUser.DoesNotExist:
            employee_name = employee.employee_id
        
        subject = f"ALERT: Employee {employee.employee_id} needs attention"
        
        message = f"""
Attention Required: Employee Inactivity Alert

Employee ID: {employee.employee_id}
Name: {employee_name}

This employee has been inactive and has not engaged with the AI assistant despite multiple notifications.
They may need additional support or follow-up from the HR department.

This is an automated message generated by the system.

Best regards,
HR Management System
        """
        
        # Send email to all admin users
        admin_emails = [admin.email for admin in admin_users if admin.email]
        
        if admin_emails:
            send_mail(
                subject=subject,
                message=message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=admin_emails,
                fail_silently=False,
            )
            
            # Log successful email sending
            logger = logging.getLogger(__name__)
            logger.info(f"Admin alert emails sent for {employee.employee_id} to {len(admin_emails)} admin(s)")
        else:
            logger = logging.getLogger(__name__)
            logger.warning(f"No admin email addresses found to send alert for {employee.employee_id}")
            
    except Exception as e:
        # Log any errors but don't break the flow
        logger = logging.getLogger(__name__)
        logger.error(f"Error sending admin alert emails for {employee.employee_id}: {str(e)}")

def should_send_notification(employee):
    """Check if a notification should be sent to the employee."""
    # Fetch the user using employee_id as username
    try:
        user = CustomUser.objects.get(username=employee.employee_id)
        
        # Check if employee has any chat messages
        has_chat_messages = ChatMessage.objects.filter(user=user).exists()
        if has_chat_messages:
            return False

        # Get current notifications
        notifications = employee.notifications or []
        if len(notifications) >= 3:
            # If employee has 3 or more notifications and still no chat messages,
            # mark them as alerted
            if not has_chat_messages and not employee.is_alerted:
                employee.is_alerted = True
                employee.save()
                
                # Send alert emails to all admin users
                send_admin_alert(employee)
                
            return False

        return True
    except CustomUser.DoesNotExist:
        return False

def create_notification(employee):
    """Create a new notification for the employee and send an email."""
    # Fetch the user to get their email
    try:
        user = CustomUser.objects.get(username=employee.employee_id)
        
        # Create notification
        notifications = employee.notifications or []
        notification_count = len(notifications) + 1
        
        new_notification = {
            'id': notification_count,
            'message': 'Please start chatting with our AI assistant to improve your experience.',
            'created_at': timezone.now().isoformat(),
            'sent': False
        }
        notifications.append(new_notification)
        employee.notifications = notifications
        employee.save()
        
        # Send email to the user
        subject = "Inactivity Notification - Please Engage with Our AI Assistant"
        
        # Customize message based on notification count
        urgency_level = ""
        if notification_count == 1:
            urgency_level = "We've noticed that you haven't interacted with our AI assistant yet."
        elif notification_count == 2:
            urgency_level = "This is our second notification regarding your inactivity with our AI assistant. We encourage you to try it out soon."
        elif notification_count >= 3:
            urgency_level = "This is our final reminder about your inactivity with our AI assistant. Please engage with it as soon as possible."
        
        message = f"""
Hello {user.username},

{urgency_level}
Chatting with our AI assistant can help you:
- Get instant support for your work-related queries
- Improve your productivity
- Access personalized assistance

Please log in to your account and start a conversation with our AI assistant today.

Best regards,
The HR Team
        """
        
        recipient_email = user.email
        
        # Send the email
        send_mail(
            subject=subject,
            message=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[recipient_email],
            fail_silently=False,
        )
        
        # Log successful email sending
        logger = logging.getLogger(__name__)
        logger.info(f"Notification email #{notification_count} sent to {user.email} (Employee ID: {employee.employee_id})")
        
    except CustomUser.DoesNotExist:
        # Log this issue
        logger = logging.getLogger(__name__)
        logger.error(f"Failed to find user for employee ID: {employee.employee_id}")
        
    except Exception as e:
        # Log any other errors but don't prevent notification creation
        logger = logging.getLogger(__name__)
        logger.error(f"Error sending email to {employee.employee_id}: {str(e)}")

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def check_notification(request):
    """Handle notification check from client at 10 AM."""
    current_time = timezone.localtime().time()
    target_time = time(10, 0)  # 10 AM

    # Only process if it's around 10 AM (within a minute margin)
    if abs((current_time.hour * 60 + current_time.minute) - (target_time.hour * 60 + target_time.minute)) > 1:
        return Response({'received': False, 'message': 'Not notification time'})

    try:
        username = request.data.get("username")
        employee = TablesEmployee.objects.get(employee_id=username)
        notifications = employee.notifications or []
        
        # Find the latest unsent notification
        for notification in notifications:
            if not notification['sent']:
                notification['sent'] = True
                employee.notifications = notifications
                employee.save()
                return Response({'received': True, 'notification': notification})

        return Response({'received': False, 'message': 'No pending notifications'})

    except TablesEmployee.DoesNotExist:
        return Response({'received': False, 'message': 'Employee not found'}, status=404)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def test_admin_alert(request):
    """Test endpoint to manually trigger admin alert for a specific employee.
    This is for testing purposes only and should be disabled in production.
    """
    # Only allow admin users to access this endpoint
    if request.user.role != 'admin':
        return Response({'error': 'Only admin users can access this endpoint'}, status=403)
    
    employee_id = request.data.get('employee_id')
    if not employee_id:
        return Response({'error': 'employee_id is required'}, status=400)
    
    try:
        employee = TablesEmployee.objects.get(employee_id=employee_id)
        
        # Set is_alerted to true if not already
        if not employee.is_alerted:
            employee.is_alerted = True
            employee.save()
        
        # Send admin alert
        send_admin_alert(employee)
        
        return Response({
            'success': True, 
            'message': f'Admin alert sent for employee {employee_id}'
        })
        
    except TablesEmployee.DoesNotExist:
        return Response({
            'error': f'Employee with ID {employee_id} not found'
        }, status=404)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def mark_employee_alerted(request):
    """Mark an employee as alerted and send notifications to all admin users.
    This endpoint is for manually marking an employee as needing attention.
    """
    # Verify user has permission (either admin or the employee's manager)
    if request.user.role != 'admin':
        return Response({'error': 'Only admin users can access this endpoint'}, status=403)
    
    employee_id = request.data.get('employee_id')
    if not employee_id:
        return Response({'error': 'employee_id is required'}, status=400)
    
    try:
        employee = TablesEmployee.objects.get(employee_id=employee_id)
        
        # Skip if already alerted
        if employee.is_alerted:
            return Response({
                'message': f'Employee {employee_id} is already marked as alerted',
                'already_alerted': True
            })
        
        # Mark employee as alerted
        employee.is_alerted = True
        employee.save()
        
        # Send alert to admin users
        send_admin_alert(employee)
        
        return Response({
            'success': True,
            'message': f'Employee {employee_id} has been marked as alerted and notifications sent to admin users'
        })
        
    except TablesEmployee.DoesNotExist:
        return Response({
            'error': f'Employee with ID {employee_id} not found'
        }, status=404) 